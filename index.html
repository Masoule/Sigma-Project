<script src="../lib/sigma.min.js"></script>
<script src="../lib/sigma.parsers.json.min.js"></script>
<script src="../lib/sigma.layout.forceAtlas2.min.js"></script>
<script src="../lib/jquery-2.1.1.min.js"></script>

<script src="../plugins/sigma.plugins.neighborhoods/sigma.plugins.neighborhoods.js"></script>
<script src="../plugins/sigma.layout.forceAtlas2/supervisor.js"></script>
<script src="../plugins/sigma.layout.forceAtlas2/worker.js"></script>

<!-- <script src="../lib/graph.js"></script> -->
<link rel="stylesheet" href="style.css">

<div id="container">
    <div id="graph-container"></div>
</div>

<script>
    var i,
        s,
        N = 100,
        E = 200,
        graph = {
          nodes: [],
          edges: []
        };

    // Generate a random graph:
    for (i = 0; i < N; i++)
      graph.nodes.push({
        id: 'n' + i,
        label: 'Node ' + i,
        x: Math.random(),
        y: Math.random(),
        size: Math.random(),
        color: '#666'
      });

    for (i = 0; i < E; i++)
      graph.edges.push({
        id: 'e' + i,
        source: 'n' + (Math.random() * N | 0),
        target: 'n' + (Math.random() * N | 0),
        size: Math.random(),
        color: '#ccc',
        // type: 'curvedArrow',
      });

      // Initialise sigma:
    s = new sigma({
      graph: graph,
      renderer: {
          id: 'main-renderer',
          container: document.getElementById('graph-container'),
          type: 'canvas',
          // type: 'svg',
          freeStyle: true
      },
      settings: {
        enableHovering: false,
        edgeLabelSize: 'proportional',
        minArrowSize: 10
      }
    });

    // load the graph
    // s.graph.read(graph);

    // draw the graph
    s.refresh();

    // launch force-atlas for 5sec
    // s.startForceAtlas2();
    // window.setTimeout(function() { s.killForceAtlas2() }, 3000);


    // Binding silly interactions
    function mute(node) {
      if (!~node.getAttribute('class').search(/muted/))
        node.setAttributeNS(null, 'class', node.getAttribute('class') + ' muted');
    }

    function unmute(node) {
      node.setAttributeNS(null, 'class', node.getAttribute('class').replace(/(\s|^)muted(\s|$)/g, '$2'));
    }

    $('.sigma-node').click(function() {

      // Muting
      $('.sigma-node, .sigma-edge').each(function() {
        mute(this);
      });

      // Unmuting neighbors
      var neighbors = s.graph.neighborhood($(this).attr('data-node-id'));
      neighbors.nodes.forEach(function(node) {
        unmute($('[data-node-id="' + node.id + '"]')[0]);
      });

      neighbors.edges.forEach(function(edge) {
        unmute($('[data-edge-id="' + edge.id + '"]')[0]);
      });
    });

    s.bind('clickStage', function() {
      $('.sigma-node, .sigma-edge').each(function() {
        unmute(this);
      });
    });
</script>
